# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.6.3

# type: ignore

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress

PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), "."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class gofp:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "gofp"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("gofp")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(self, transaction_config):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(transaction_config)
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def admin_terminus_info(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.adminTerminusInfo.call(block_identifier=block_number)

    def choose_current_stage_paths(
        self, session_id: int, token_ids: List, paths: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.chooseCurrentStagePaths(
            session_id, token_ids, paths, transaction_config
        )

    def create_session(
        self,
        player_token_address: ChecksumAddress,
        payment_token_address: ChecksumAddress,
        payment_amount: int,
        is_active: bool,
        uri: str,
        stages: List,
        is_forgiving: bool,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.createSession(
            player_token_address,
            payment_token_address,
            payment_amount,
            is_active,
            uri,
            stages,
            is_forgiving,
            transaction_config,
        )

    def get_correct_path_for_stage(
        self,
        session_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getCorrectPathForStage.call(
            session_id, stage, block_identifier=block_number
        )

    def get_current_stage(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getCurrentStage.call(
            session_id, block_identifier=block_number
        )

    def get_path_choice(
        self,
        session_id: int,
        token_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getPathChoice.call(
            session_id, token_id, stage, block_identifier=block_number
        )

    def get_session(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getSession.call(session_id, block_identifier=block_number)

    def get_session_token_stake_guard(
        self,
        session_id: int,
        token_id: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getSessionTokenStakeGuard.call(
            session_id, token_id, block_identifier=block_number
        )

    def get_stage_reward(
        self,
        session_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getStageReward.call(
            session_id, stage, block_identifier=block_number
        )

    def get_staked_token_info(
        self,
        nft_address: ChecksumAddress,
        token_id: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getStakedTokenInfo.call(
            nft_address, token_id, block_identifier=block_number
        )

    def init(
        self,
        admin_terminus_address: ChecksumAddress,
        admin_terminus_pool_id: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.init(
            admin_terminus_address, admin_terminus_pool_id, transaction_config
        )

    def num_sessions(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.numSessions.call(block_identifier=block_number)

    def num_tokens_staked_into_session(
        self,
        session_id: int,
        staker: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.numTokensStakedIntoSession.call(
            session_id, staker, block_identifier=block_number
        )

    def on_erc1155_batch_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: List,
        arg4: List,
        arg5: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC1155BatchReceived(
            arg1, arg2, arg3, arg4, arg5, transaction_config
        )

    def on_erc1155_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: int,
        arg4: int,
        arg5: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC1155Received(
            arg1, arg2, arg3, arg4, arg5, transaction_config
        )

    def on_erc721_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: int,
        arg4: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC721Received(
            arg1, arg2, arg3, arg4, transaction_config
        )

    def set_correct_path_for_stage(
        self,
        session_id: int,
        stage: int,
        path: int,
        set_is_choosing_active: bool,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setCorrectPathForStage(
            session_id, stage, path, set_is_choosing_active, transaction_config
        )

    def set_session_active(
        self, session_id: int, is_active: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionActive(session_id, is_active, transaction_config)

    def set_session_choosing_active(
        self, session_id: int, is_choosing_active: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionChoosingActive(
            session_id, is_choosing_active, transaction_config
        )

    def set_session_uri(self, session_id: int, uri: str, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionUri(session_id, uri, transaction_config)

    def set_stage_rewards(
        self,
        session_id: int,
        stages: List,
        terminus_addresses: List,
        terminus_pool_ids: List,
        reward_amounts: List,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setStageRewards(
            session_id,
            stages,
            terminus_addresses,
            terminus_pool_ids,
            reward_amounts,
            transaction_config,
        )

    def stake_tokens_into_session(
        self, session_id: int, token_ids: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.stakeTokensIntoSession(
            session_id, token_ids, transaction_config
        )

    def supports_interface(
        self, interface_id: bytes, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.supportsInterface.call(
            interface_id, block_identifier=block_number
        )

    def token_of_staker_in_session_by_index(
        self,
        session_id: int,
        staker: ChecksumAddress,
        index: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.tokenOfStakerInSessionByIndex.call(
            session_id, staker, index, block_identifier=block_number
        )

    def unstake_tokens_from_session(
        self, session_id: int, token_ids: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.unstakeTokensFromSession(
            session_id, token_ids, transaction_config
        )


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = gofp(None)
    result = contract.deploy(transaction_config=transaction_config)
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.verify_contract()
    print(result)


def handle_admin_terminus_info(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.admin_terminus_info(block_number=args.block_number)
    print(result)


def handle_choose_current_stage_paths(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.choose_current_stage_paths(
        session_id=args.session_id,
        token_ids=args.token_ids,
        paths=args.paths,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_create_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.create_session(
        player_token_address=args.player_token_address,
        payment_token_address=args.payment_token_address,
        payment_amount=args.payment_amount,
        is_active=args.is_active,
        uri=args.uri,
        stages=args.stages,
        is_forgiving=args.is_forgiving,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_correct_path_for_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_correct_path_for_stage(
        session_id=args.session_id, stage=args.stage, block_number=args.block_number
    )
    print(result)


def handle_get_current_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_current_stage(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_get_path_choice(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_path_choice(
        session_id=args.session_id,
        token_id=args.token_id,
        stage=args.stage,
        block_number=args.block_number,
    )
    print(result)


def handle_get_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_session(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_get_session_token_stake_guard(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_session_token_stake_guard(
        session_id=args.session_id,
        token_id=args.token_id,
        block_number=args.block_number,
    )
    print(result)


def handle_get_stage_reward(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_stage_reward(
        session_id=args.session_id, stage=args.stage, block_number=args.block_number
    )
    print(result)


def handle_get_staked_token_info(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.get_staked_token_info(
        nft_address=args.nft_address,
        token_id=args.token_id,
        block_number=args.block_number,
    )
    print(result)


def handle_init(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.init(
        admin_terminus_address=args.admin_terminus_address,
        admin_terminus_pool_id=args.admin_terminus_pool_id,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_num_sessions(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.num_sessions(block_number=args.block_number)
    print(result)


def handle_num_tokens_staked_into_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.num_tokens_staked_into_session(
        session_id=args.session_id, staker=args.staker, block_number=args.block_number
    )
    print(result)


def handle_on_erc1155_batch_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc1155_batch_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        arg5=args.arg5,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_erc1155_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc1155_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        arg5=args.arg5,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_erc721_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc721_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_correct_path_for_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_correct_path_for_stage(
        session_id=args.session_id,
        stage=args.stage,
        path=args.path,
        set_is_choosing_active=args.set_is_choosing_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_active(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_active(
        session_id=args.session_id,
        is_active=args.is_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_choosing_active(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_choosing_active(
        session_id=args.session_id,
        is_choosing_active=args.is_choosing_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_uri(
        session_id=args.session_id, uri=args.uri, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_stage_rewards(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_stage_rewards(
        session_id=args.session_id,
        stages=args.stages,
        terminus_addresses=args.terminus_addresses,
        terminus_pool_ids=args.terminus_pool_ids,
        reward_amounts=args.reward_amounts,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_stake_tokens_into_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.stake_tokens_into_session(
        session_id=args.session_id,
        token_ids=args.token_ids,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_supports_interface(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.supports_interface(
        interface_id=args.interface_id, block_number=args.block_number
    )
    print(result)


def handle_token_of_staker_in_session_by_index(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    result = contract.token_of_staker_in_session_by_index(
        session_id=args.session_id,
        staker=args.staker,
        index=args.index,
        block_number=args.block_number,
    )
    print(result)


def handle_unstake_tokens_from_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = gofp(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.unstake_tokens_from_session(
        session_id=args.session_id,
        token_ids=args.token_ids,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for gofp")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    admin_terminus_info_parser = subcommands.add_parser("admin-terminus-info")
    add_default_arguments(admin_terminus_info_parser, False)
    admin_terminus_info_parser.set_defaults(func=handle_admin_terminus_info)

    choose_current_stage_paths_parser = subcommands.add_parser(
        "choose-current-stage-paths"
    )
    add_default_arguments(choose_current_stage_paths_parser, True)
    choose_current_stage_paths_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    choose_current_stage_paths_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    choose_current_stage_paths_parser.add_argument(
        "--paths", required=True, help="Type: uint256[]", nargs="+"
    )
    choose_current_stage_paths_parser.set_defaults(
        func=handle_choose_current_stage_paths
    )

    create_session_parser = subcommands.add_parser("create-session")
    add_default_arguments(create_session_parser, True)
    create_session_parser.add_argument(
        "--player-token-address", required=True, help="Type: address"
    )
    create_session_parser.add_argument(
        "--payment-token-address", required=True, help="Type: address"
    )
    create_session_parser.add_argument(
        "--payment-amount", required=True, help="Type: uint256", type=int
    )
    create_session_parser.add_argument(
        "--is-active", required=True, help="Type: bool", type=boolean_argument_type
    )
    create_session_parser.add_argument(
        "--uri", required=True, help="Type: string", type=str
    )
    create_session_parser.add_argument(
        "--stages", required=True, help="Type: uint256[]", nargs="+"
    )
    create_session_parser.add_argument(
        "--is-forgiving", required=True, help="Type: bool", type=boolean_argument_type
    )
    create_session_parser.set_defaults(func=handle_create_session)

    get_correct_path_for_stage_parser = subcommands.add_parser(
        "get-correct-path-for-stage"
    )
    add_default_arguments(get_correct_path_for_stage_parser, False)
    get_correct_path_for_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_correct_path_for_stage_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_correct_path_for_stage_parser.set_defaults(
        func=handle_get_correct_path_for_stage
    )

    get_current_stage_parser = subcommands.add_parser("get-current-stage")
    add_default_arguments(get_current_stage_parser, False)
    get_current_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_current_stage_parser.set_defaults(func=handle_get_current_stage)

    get_path_choice_parser = subcommands.add_parser("get-path-choice")
    add_default_arguments(get_path_choice_parser, False)
    get_path_choice_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.set_defaults(func=handle_get_path_choice)

    get_session_parser = subcommands.add_parser("get-session")
    add_default_arguments(get_session_parser, False)
    get_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_session_parser.set_defaults(func=handle_get_session)

    get_session_token_stake_guard_parser = subcommands.add_parser(
        "get-session-token-stake-guard"
    )
    add_default_arguments(get_session_token_stake_guard_parser, False)
    get_session_token_stake_guard_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_session_token_stake_guard_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    get_session_token_stake_guard_parser.set_defaults(
        func=handle_get_session_token_stake_guard
    )

    get_stage_reward_parser = subcommands.add_parser("get-stage-reward")
    add_default_arguments(get_stage_reward_parser, False)
    get_stage_reward_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_stage_reward_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_stage_reward_parser.set_defaults(func=handle_get_stage_reward)

    get_staked_token_info_parser = subcommands.add_parser("get-staked-token-info")
    add_default_arguments(get_staked_token_info_parser, False)
    get_staked_token_info_parser.add_argument(
        "--nft-address", required=True, help="Type: address"
    )
    get_staked_token_info_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    get_staked_token_info_parser.set_defaults(func=handle_get_staked_token_info)

    init_parser = subcommands.add_parser("init")
    add_default_arguments(init_parser, True)
    init_parser.add_argument(
        "--admin-terminus-address", required=True, help="Type: address"
    )
    init_parser.add_argument(
        "--admin-terminus-pool-id", required=True, help="Type: uint256", type=int
    )
    init_parser.set_defaults(func=handle_init)

    num_sessions_parser = subcommands.add_parser("num-sessions")
    add_default_arguments(num_sessions_parser, False)
    num_sessions_parser.set_defaults(func=handle_num_sessions)

    num_tokens_staked_into_session_parser = subcommands.add_parser(
        "num-tokens-staked-into-session"
    )
    add_default_arguments(num_tokens_staked_into_session_parser, False)
    num_tokens_staked_into_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    num_tokens_staked_into_session_parser.add_argument(
        "--staker", required=True, help="Type: address"
    )
    num_tokens_staked_into_session_parser.set_defaults(
        func=handle_num_tokens_staked_into_session
    )

    on_erc1155_batch_received_parser = subcommands.add_parser(
        "on-erc1155-batch-received"
    )
    add_default_arguments(on_erc1155_batch_received_parser, True)
    on_erc1155_batch_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256[]", nargs="+"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg4", required=True, help="Type: uint256[]", nargs="+"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg5", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc1155_batch_received_parser.set_defaults(func=handle_on_erc1155_batch_received)

    on_erc1155_received_parser = subcommands.add_parser("on-erc1155-received")
    add_default_arguments(on_erc1155_received_parser, True)
    on_erc1155_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc1155_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc1155_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256", type=int
    )
    on_erc1155_received_parser.add_argument(
        "--arg4", required=True, help="Type: uint256", type=int
    )
    on_erc1155_received_parser.add_argument(
        "--arg5", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc1155_received_parser.set_defaults(func=handle_on_erc1155_received)

    on_erc721_received_parser = subcommands.add_parser("on-erc721-received")
    add_default_arguments(on_erc721_received_parser, True)
    on_erc721_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc721_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc721_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256", type=int
    )
    on_erc721_received_parser.add_argument(
        "--arg4", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc721_received_parser.set_defaults(func=handle_on_erc721_received)

    set_correct_path_for_stage_parser = subcommands.add_parser(
        "set-correct-path-for-stage"
    )
    add_default_arguments(set_correct_path_for_stage_parser, True)
    set_correct_path_for_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--path", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--set-is-choosing-active",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    set_correct_path_for_stage_parser.set_defaults(
        func=handle_set_correct_path_for_stage
    )

    set_session_active_parser = subcommands.add_parser("set-session-active")
    add_default_arguments(set_session_active_parser, True)
    set_session_active_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_active_parser.add_argument(
        "--is-active", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_session_active_parser.set_defaults(func=handle_set_session_active)

    set_session_choosing_active_parser = subcommands.add_parser(
        "set-session-choosing-active"
    )
    add_default_arguments(set_session_choosing_active_parser, True)
    set_session_choosing_active_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_choosing_active_parser.add_argument(
        "--is-choosing-active",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    set_session_choosing_active_parser.set_defaults(
        func=handle_set_session_choosing_active
    )

    set_session_uri_parser = subcommands.add_parser("set-session-uri")
    add_default_arguments(set_session_uri_parser, True)
    set_session_uri_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_uri_parser.add_argument(
        "--uri", required=True, help="Type: string", type=str
    )
    set_session_uri_parser.set_defaults(func=handle_set_session_uri)

    set_stage_rewards_parser = subcommands.add_parser("set-stage-rewards")
    add_default_arguments(set_stage_rewards_parser, True)
    set_stage_rewards_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_stage_rewards_parser.add_argument(
        "--stages", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--terminus-addresses", required=True, help="Type: address[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--terminus-pool-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--reward-amounts", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.set_defaults(func=handle_set_stage_rewards)

    stake_tokens_into_session_parser = subcommands.add_parser(
        "stake-tokens-into-session"
    )
    add_default_arguments(stake_tokens_into_session_parser, True)
    stake_tokens_into_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    stake_tokens_into_session_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    stake_tokens_into_session_parser.set_defaults(func=handle_stake_tokens_into_session)

    supports_interface_parser = subcommands.add_parser("supports-interface")
    add_default_arguments(supports_interface_parser, False)
    supports_interface_parser.add_argument(
        "--interface-id", required=True, help="Type: bytes4", type=bytes_argument_type
    )
    supports_interface_parser.set_defaults(func=handle_supports_interface)

    token_of_staker_in_session_by_index_parser = subcommands.add_parser(
        "token-of-staker-in-session-by-index"
    )
    add_default_arguments(token_of_staker_in_session_by_index_parser, False)
    token_of_staker_in_session_by_index_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    token_of_staker_in_session_by_index_parser.add_argument(
        "--staker", required=True, help="Type: address"
    )
    token_of_staker_in_session_by_index_parser.add_argument(
        "--index", required=True, help="Type: uint256", type=int
    )
    token_of_staker_in_session_by_index_parser.set_defaults(
        func=handle_token_of_staker_in_session_by_index
    )

    unstake_tokens_from_session_parser = subcommands.add_parser(
        "unstake-tokens-from-session"
    )
    add_default_arguments(unstake_tokens_from_session_parser, True)
    unstake_tokens_from_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    unstake_tokens_from_session_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    unstake_tokens_from_session_parser.set_defaults(
        func=handle_unstake_tokens_from_session
    )

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
